{"mappings":"AC2FE,MAAM,EAAW,GAzFI,IAAO,CAAA,CAC5B,IAAM,GACN,MAAQ,EACR,OAAS,EAET,KAAO,SAAS,CAAI,EAClB,IAAI,CAAC,GAAA,CAAM,EAAK,GAAhB,CACA,IAAI,CAAC,KAAA,CAAQ,EAAK,KAAlB,CACA,IAAI,CAAC,MAAA,CAAS,EAAK,MAAnB,CACA,IAAI,CAAC,UAAA,CAAW,IAAI,CAAC,UAArB,EACA,IAAI,CAAC,cAAA,CAAe,IAAI,CAAC,qBAAA,CAAsB,IAAI,CAAC,iBAAA,CAAkB,IAAA,CAAK,IAAI,GACjF,EAGA,WAAa,eAAe,CAAQ,EAC5B,IAAI,EAAM,IAAI,CAAC,GAAf,CAEA,GADY,CAAC,OAAO,EAAE,IAAI,CAAC,KAAA,CAAM,QAAQ,EAAE,IAAI,CAAC,MAAA,CAAO,CAAC,CAExD,MAAM,MAAM,GAAK,IAAA,CAAK,AAAA,GAAO,EAAI,IAAA,IAChC,IAAA,CAAK,AAAA,GAAO,EAAS,IACrB,KAAA,CAAM,AAAA,GAAS,QAAQ,GAAA,CAAI,GAC9B,EAGN,WAAY,SAAS,CAAI,EAErB,IAAM,EAAY,SAAS,aAAA,CAAc,QACzC,EAAK,MAAA,CAAO,OAAA,CAAQ,AAAA,IAClB,IAAM,EAAM,SAAS,aAAA,CAAc,MACnC,CAAA,EAAI,GAAA,CAAM,EAAK,GAAf,CACA,EAAI,KAAA,CAAQ,IACZ,EAAU,MAAA,CAAO,EAEnB,EACF,EAUF,sBAAwB,SAAS,CAAQ,EACrC,IAAI,EAAU,CAAA,EACV,EAAS,IAAI,CAAC,MAAlB,CACI,EAAQ,IAAI,CAAC,KAAjB,CACA,MAAO,KAGD,SAAS,eAAA,CAAgB,YAAA,CAC7B,CAAA,SAAS,eAAA,CAAgB,SAAA,CACzB,SAAS,eAAA,CAAgB,YAAW,AAAX,EAAgB,IAAO,IAC9C,QAAQ,GAAA,CAAI,GACZ,EAAU,CAAA,EACV,QAAQ,GAAA,CAAI,cAAgB,SAAS,eAAA,CAAgB,YAAA,CACnD,CAAA,SAAS,eAAA,CAAgB,SAAA,CACzB,SAAS,eAAA,CAAgB,YAAW,AAAX,GAC3B,EAAS,EAAO,GAAQ,IAAA,CAAK,AAAA,IAC3B,GAAU,EACV,EAAU,CAAA,CAEZ,GAEJ,CACF,EAKF,kBAAoB,WAChB,OAAO,IAAI,QAAQ,CAAC,EAAS,KAC3B,IAAI,CAAC,UAAA,CAAW,IAAI,CAAC,UAAA,EACpB,IAAA,CAAK,AAAA,GAAO,EAAQ,WAEzB,EACF,EAKA,eAAiB,SAAS,CAAc,EACpC,OAAO,gBAAA,CAAiB,SAAU,EACtC,CACF,CAAA,EAKE,EAAS,IAAA,CAAK,CACZ,IAAM,qDACN,MAAQ,EACR,OAAS,CACX","sources":["<anon>","src/index.mjs"],"sourcesContent":["\nconst $761f97bf09d51d3e$var$infiniteScroll = ()=>({\n        url: \"\",\n        limit: 5,\n        offset: 0,\n        //  loading initial data to be rendered on UI for first load\n        init: function(data) {\n            this.url = data.url;\n            this.limit = data.limit;\n            this.offset = data.offset;\n            this.loadImages(this.renderData);\n            this.infiniteScroll(this.infinteScrollCallback(this.afterScrollAction.bind(this)));\n        },\n        // function to fetch data from api \n        // accepts callback function which is executed after successful fetch of data\n        loadImages: async function(callback) {\n            let url = this.url;\n            let query = `?limit=${this.limit}&offset=${this.offset}`;\n            url = url + query;\n            await fetch(url).then((res)=>res.json()).then((res)=>callback(res)).catch((error)=>console.log(error));\n        },\n        // function which creates the html elements from fetched data\n        // and renders on the DOM\n        renderData: function(data) {\n            //console.log(data);\n            const container = document.querySelector(\"#app\");\n            data.photos.forEach((item)=>{\n                const img = document.createElement(\"img\");\n                img.src = item.url;\n                img.width = 200;\n                container.append(img);\n            //console.log(container);\n            });\n        },\n        // this functions contains the logic of scroll effect i.e., when \n        // should the scroll event should trigger to load data, \n        // any private variable setup for the callback.\n        // this function gets executed as callback when our infinite\n        // scrollbar gets triggered. \n        // It accepts a promise callback function\n        // which is called when scroll condition is met.\n        infinteScrollCallback: function(callback) {\n            var calling = true;\n            var offset = this.offset;\n            var limit = this.limit;\n            return ()=>{\n                //console.log(\"before if: \", calling);\n                if (document.documentElement.scrollHeight - (document.documentElement.scrollTop + document.documentElement.clientHeight) < 50 && calling) {\n                    console.log(calling);\n                    calling = false;\n                    console.log(\"scrolled : \", document.documentElement.scrollHeight - (document.documentElement.scrollTop + document.documentElement.clientHeight));\n                    callback(limit, offset).then((res)=>{\n                        offset += limit;\n                        calling = true;\n                        return;\n                    });\n                }\n            };\n        },\n        // this is the callback function which is passed in infite scroll method\n        // this controls what action we need to perform once scroll condition is met.\n        // it should return promise\n        afterScrollAction: function() {\n            return new Promise((resolve, reject)=>{\n                this.loadImages(this.renderData).then((res)=>resolve(\"success\"));\n            //      resolve('success');\n            });\n        },\n        // method to add scroll event listener\n        // accepts a callback function  which is called on every scroll \n        // event triggering\n        infiniteScroll: function(scrollcallback) {\n            window.addEventListener(\"scroll\", scrollcallback);\n        }\n    });\n// initializing the infinite scrollbar feature on DOM\nconst $761f97bf09d51d3e$var$infinite = new $761f97bf09d51d3e$var$infiniteScroll();\n$761f97bf09d51d3e$var$infinite.init({\n    url: \"https://api.slingacademy.com/v1/sample-data/photos\",\n    limit: 5,\n    offset: 0\n});\n\n\n//# sourceMappingURL=index.86743cfe.js.map\n","import \"./styles.css\";\n\nconst infiniteScroll = () => ({\n  url : \"\",\n  limit : 5,\n  offset : 0,\n  //  loading initial data to be rendered on UI for first load\n  init : function(data) { \n    this.url = data.url;\n    this.limit = data.limit;\n    this.offset = data.offset;\n    this.loadImages(this.renderData);\n    this.infiniteScroll(this.infinteScrollCallback(this.afterScrollAction.bind(this)));\n  },\n  // function to fetch data from api \n  // accepts callback function which is executed after successful fetch of data\n  loadImages : async function(callback) {\n          let url = this.url;\n          let query = `?limit=${this.limit}&offset=${this.offset}`;\n          url = url + query;\n          await fetch(url).then(res => res.json())\n          .then(res => callback(res))\n          .catch(error => console.log(error));\n        },\n  // function which creates the html elements from fetched data\n  // and renders on the DOM\n  renderData: function(data){\n      //console.log(data);\n      const container = document.querySelector(\"#app\");\n      data.photos.forEach(item => {\n        const img = document.createElement('img');\n        img.src = item.url;\n        img.width = 200;\n        container.append(img);\n        //console.log(container);\n      })\n    },\n\n  // this functions contains the logic of scroll effect i.e., when \n  // should the scroll event should trigger to load data, \n  // any private variable setup for the callback.\n  // this function gets executed as callback when our infinite\n  // scrollbar gets triggered. \n  // It accepts a promise callback function\n  // which is called when scroll condition is met.\n\n  infinteScrollCallback : function(callback) {\n      var calling = true;\n      var offset = this.offset;\n      var limit = this.limit;\n      return () => {     \n        //console.log(\"before if: \", calling);\n        \n        if((document.documentElement.scrollHeight - (\n        document.documentElement.scrollTop + \n        document.documentElement.clientHeight) < 50) && calling) {\n          console.log(calling);\n          calling = false;\n          console.log(\"scrolled : \" , document.documentElement.scrollHeight - (\n            document.documentElement.scrollTop + \n            document.documentElement.clientHeight));\n          callback(limit, offset).then(res => {\n            offset += limit;\n            calling = true;\n            return;\n          });\n        }\n      };\n    },\n\n  // this is the callback function which is passed in infite scroll method\n  // this controls what action we need to perform once scroll condition is met.\n  // it should return promise\n  afterScrollAction : function() {\n      return new Promise((resolve, reject) => {\n        this.loadImages(this.renderData)\n        .then(res => resolve('success'));\n  //      resolve('success');\n    });\n  },  \n\n  // method to add scroll event listener\n  // accepts a callback function  which is called on every scroll \n  // event triggering\n  infiniteScroll : function(scrollcallback){\n      window.addEventListener(\"scroll\", scrollcallback);\n  },\n});\n\n// initializing the infinite scrollbar feature on DOM\n\n  const infinite = new infiniteScroll();\n  infinite.init({\n    url : \"https://api.slingacademy.com/v1/sample-data/photos\",\n    limit : 5,\n    offset : 0\n  })"],"names":["$761f97bf09d51d3e$var$infinite","url","limit","offset","init","data","loadImages","renderData","infiniteScroll","infinteScrollCallback","afterScrollAction","bind","callback","fetch","then","res","json","catch","error","console","log","container","document","querySelector","photos","forEach","item","img","createElement","src","width","append","calling","documentElement","scrollHeight","scrollTop","clientHeight","Promise","resolve","reject","scrollcallback","window","addEventListener"],"version":3,"file":"index.86743cfe.js.map"}